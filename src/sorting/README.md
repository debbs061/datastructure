# 1. 정렬 알고리듬 비교

|      | 평균       | 최악       | 메모     | 안정성 |
| ---- | ---------- | ---------- | -------- | ------ |
| 버블 | O(N^2)     | O(N^2)     | O(1)     | O      |
| 선택 | O(N^2)     | O(N^2)     | O(1)     | X      |
| 삽입 | O(N^2)     | O(N^2)     | O(1)     | O      |
| 퀵   | O(N Log N) | O(N^2)     | O(Log N) | X      |
| 병합 | O(N Log N) | O(N Log N) | O(N)     | O      |
| 힙   | O(N Log N) | O(N Log N) | O(1)     | X      |

* 실무에서는 퀵정렬을 가장 많이 사용한다
* 퀵의 경우 재귀함수가 사용되기 때문에 스택 메모리를 사용하는데 O(Log N) 이 걸린다는 말

# 2. 정렬 알고리듬

## 2-1. 버블 정렬

**버블 정렬의 시간 복잡도가 왜 O(N^2) 일까?**

<img src="./images/image-20210608053634519.png" alt="image-20210608053634519" style="zoom:50%;" />

* 이 목록을 훑는 횟수는 총 몇 번? N-1 번

* 한 번 훑을 때

    * 가장 많이 방문했던 요소 수는? N-1 (1회차)
    * 가장 적게 방문했던 요소 수는? 1 (6회차)
    * 평균적으로 방문했던 요소 수는? (N-1+1)/2 = N/2
    * 시간복잡도: O((N-1)N/2) = O(N^2)



## 2-2. 선택 정렬

* 최솟값을 찾아 선택한다고 해서 선택 정렬
* 프로그래밍을 배우지 않은 사람한테 정렬하라고 하면 대부분 이런식으로 정렬한다. (반 친구들 키 오름차순 순서대로 세우기)



## 2-3. 삽입 정렬

* 외부 반복문의 반복 횟수는 고정 (모든 요소를 방문하긴 해야하니깐)
    * O(N)
    * 정해진 횟수니 *for문*이 적합
* 내부 반복문의 반복 횟수는 가변적
    * 필요한 만큼까지만 오른쪽으로 미는 방식
        * 시간 복잡도로는 여전히 O(N)
    * 정해지지 않은 횟수이니 *while문*이 더 적합
* 시간/공간 복잡도: 버블 정렬과 동일
* 안정성: 보장 됨

<img src="./images/image-20210608052434555.png" alt="image-20210608052434555" style="zoom:50%;" />



---

### 참조

* Pope - 알고리듬 및 자료구조